Difference between comparator and comparable in java

    Comparator functional interface.
    Comparable functional interface.

    🔷 Comparable
    Package: java.lang
    Purpose: Defines the natural/default ordering of objects.
    Method: int compareTo(T o)
    Implemented by: The class whose objects need to be sorted.
    Modifies class: ✅ Yes — the class must implement Comparable.
    Sorting logic: Defined inside the class.
    Use case: When you want a single, default sort order (e.g., sort by ID).
    Lambda support: ❌ Not a functional interface — cannot use with lambdas.
    Example:

    🔷 Comparator
    Package: java.util
    Purpose: Defines custom or multiple sorting strategies.
    Method: int compare(T o1, T o2)
    Implemented by: A separate class or passed as a lambda.
    Modifies class: ❌ No — can be used externally.
    Sorting logic: Defined outside the class.
    Use case: When you want different ways to sort (e.g., by name, age).
    Lambda support: ✅ Yes — it’s a functional interface.


🔹 2. What are the main principles of OOP in Java?

    Encapsulation – Hiding internal state using access modifiers.
    Abstraction – Hiding implementation details using interfaces/abstract classes.
    Inheritance – Reusing code via parent-child relationships.
    Polymorphism – One interface, many implementations (method overloading/overriding).



2. What is the difference between HashSet and TreeSet?

    HashSet:

    Unordered.
    Uses hashing.
    Faster for insert/search/delete.


    TreeSet:

    Ordered (sorted).
    Uses Red-Black Tree.
    Slower but maintains natural or custom order.


3. How does HashMap work internally?

    Uses an array of buckets.
    Each bucket is a linked list or tree (Java 8+).
    Hash function computes index from key’s hashCode().
    Handles collisions using chaining or treeification.
    Load factor and capacity affect resizing.


4. What is the difference between Iterator and ListIterator?

    Iterator:

    Works with all collections.
    Supports forward traversal only.
    Allows element removal.


    ListIterator:

    Works only with List.
    Supports bidirectional traversal.
    Can add, remove, and replace elements.


6. What is fail-fast vs fail-safe in collections?

    Fail-fast:

    Throws ConcurrentModificationException if structure is modified during iteration.
    Examples: ArrayList, HashMap.


    Fail-safe:

    Uses copy of the collection for iteration.
    No exception on modification.
    Examples: ConcurrentHashMap, CopyOnWriteArrayList.


4. What is the use of filter() in streams?

    Used to select elements based on a condition.
    Returns a stream with matching elements only.
    Example: stream.filter(x -> x > 10)

5. How to convert A stream of intergers to stream of strings, what approach you follow?

6. How do you sort a stream?





Coding................
1. Find the maximum sum of a subarray of size k
Problem: Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k.

public static int maxSum(int[] arr, int k) {
    int max = 0, windowSum = 0;

    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    max = windowSum;

    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i] - arr[i - k];
        max = Math.max(max, windowSum);
    }

    return max;
}

🔍 Why Use Spring Cloud with Spring Boot?
Spring Boot simplifies the development of standalone Spring applications. When you start building microservices with Spring Boot, you often need additional capabilities to manage the complexity of distributed systems. That’s where Spring Cloud comes in.
Here’s why Spring Cloud is used with Spring Boot:
1. Service Discovery (Eureka)

Automatically registers services and allows them to discover each other.
Useful in dynamic environments where services scale up/down.

2. Centralized Configuration (Spring Cloud Config)

Externalizes configuration from services.
Supports versioned configuration stored in Git or other sources.

3. Load Balancing (Spring Cloud + Ribbon or Spring Cloud LoadBalancer)

Distributes traffic across multiple instances of a service.
Works with service discovery to route requests intelligently.

4. API Gateway (Spring Cloud Gateway)

Acts as a single entry point for all microservices.
Handles routing, filtering, authentication, and more.

5. Circuit Breaker (Resilience4j or Hystrix)

Prevents cascading failures by stopping calls to failing services.
Provides fallback mechanisms.

6. Distributed Tracing (Sleuth + Zipkin)

Tracks requests across multiple services.
Helps in debugging and performance monitoring.

7. Messaging and Event-Driven Architecture

Integrates with message brokers like Kafka or RabbitMQ.
Enables asynchronous communication between services.


Shrishail:- 94 Core java 97 - collections
            Angular assignments, Spring Cloud assignments all are implemented(Api gateway, Service gateway, cicuit breaker, JPA) except security facing error