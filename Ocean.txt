Difference between comparator and comparable in java

    Comparator functional interface.
    Comparable functional interface.

    🔷 Comparable
    Package: java.lang
    Purpose: Defines the natural/default ordering of objects.
    Method: int compareTo(T o)
    Implemented by: The class whose objects need to be sorted.
    Modifies class: ✅ Yes — the class must implement Comparable.
    Sorting logic: Defined inside the class.
    Use case: When you want a single, default sort order (e.g., sort by ID).
    Lambda support: ❌ Not a functional interface — cannot use with lambdas.
    Example:

    🔷 Comparator
    Package: java.util
    Purpose: Defines custom or multiple sorting strategies.
    Method: int compare(T o1, T o2)
    Implemented by: A separate class or passed as a lambda.
    Modifies class: ❌ No — can be used externally.
    Sorting logic: Defined outside the class.
    Use case: When you want different ways to sort (e.g., by name, age).
    Lambda support: ✅ Yes — it’s a functional interface.


🔹 2. What are the main principles of OOP in Java?

    Encapsulation – Hiding internal state using access modifiers.
    Abstraction – Hiding implementation details using interfaces/abstract classes.
    Inheritance – Reusing code via parent-child relationships.
    Polymorphism – One interface, many implementations (method overloading/overriding).



2. What is the difference between HashSet and TreeSet?

    HashSet:

    Unordered.
    Uses hashing.
    Faster for insert/search/delete.


    TreeSet:

    Ordered (sorted).
    Uses Red-Black Tree.
    Slower but maintains natural or custom order.


3. How does HashMap work internally?

    Uses an array of buckets.
    Each bucket is a linked list or tree (Java 8+).
    Hash function computes index from key’s hashCode().
    Handles collisions using chaining or treeification.
    Load factor and capacity affect resizing.


4. What is the difference between Iterator and ListIterator?

    Iterator:

    Works with all collections.
    Supports forward traversal only.
    Allows element removal.


    ListIterator:

    Works only with List.
    Supports bidirectional traversal.
    Can add, remove, and replace elements.


6. What is fail-fast vs fail-safe in collections?

    Fail-fast:

    Throws ConcurrentModificationException if structure is modified during iteration.
    Examples: ArrayList, HashMap.


    Fail-safe:

    Uses copy of the collection for iteration.
    No exception on modification.
    Examples: ConcurrentHashMap, CopyOnWriteArrayList.


4. What is the use of filter() in streams?

    Used to select elements based on a condition.
    Returns a stream with matching elements only.
    Example: stream.filter(x -> x > 10)

5. How to convert A stream of intergers to stream of strings, what approach you follow?

6. How do you sort a stream?





Coding................
1. Find the maximum sum of a subarray of size k
Problem: Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k.

public static int maxSum(int[] arr, int k) {
    int max = 0, windowSum = 0;

    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    max = windowSum;

    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i] - arr[i - k];
        max = Math.max(max, windowSum);
    }

    return max;
}

